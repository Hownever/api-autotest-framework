#!/bin/bash

WS=`realpath "$(dirname $0)"/../`
LOGPATH=`realpath ${WS}/../log`
ACCESSLOG=${LOGPATH}/access.log
ERRLOG=${LOGPATH}/error.log
CRONDJLOGFILE=${LOGPATH}/crond.log
WEBLOGFILE=${LOGPATH}/web.log
TCPLOGFILE=${LOGPATH}/tcp_echo_server.log

if [[ -e ${WS}/default_env.sh ]]; then
    source ${WS}/default_env.sh
fi

PROC_NAME=gunicorn # 进程名 一般就是二进制的名字java类程序一般就是java
PROC_PORT=${PROC_PORT:-80} # 程序占用的端口，建议写，程序不占用端口的话只用ps来判断进程是否启动，机器上有同名程序时可能有问题
LOGLEVEL=${LOG_LEVEL:-warning}
GUNICORN_WORKER_KILLED_AND_RESTARTED_TIME_SECS=${GUNICORN_WORKER_KILLED_AND_RESTARTED_TIME_SECS:-30}
GUNICORN_WORKER_THREADS=${GUNICORN_WORKER_THREADS:-5}
START_COMMAND="sudo -E gunicorn -w 1 -t ${GUNICORN_WORKER_KILLED_AND_RESTARTED_TIME_SECS} --threads ${GUNICORN_WORKER_THREADS} index:app -b 0.0.0.0:${PROC_PORT} --log-level=${LOGLEVEL} --access-logfile $ACCESSLOG --error-logfile $ERRLOG --daemon" #在output目录下启动你程序的命令

TCP_SERVER_NAME="python3"
TCP_ECHO_SERVER_PORT=${TCP_ECHO_SERVER_PORT:-65534}
START_COMMAND_TCP_SERVER="sudo -E /usr/bin/python3 tcp_echo_server.py ${TCP_ECHO_SERVER_PORT}"

PROC_URI= #可以用于curl访问的URI，用来判断程序是否完全启动，建议填写，写法如/healhcheck，不填则只通过检查端口是否listen了，来判断是否启动成功
RESPONSE="Crontab Job Control" #需要从返回结果里面获取的值 curl -is "http://localhost:$PROC_PORT/$PROC_URI" 用这个查看确认

WAIT_TIME=60 # 执行START_COMMAND后到程序能完全启动listen端口需要花的时间
 
PROC_NAME=${PROC_NAME::15}

[[ -d ${LOGPATH} ]] || mkdir -p ${LOGPATH}

help(){
    echo "${0} <start|stop|restart|status>"
    exit 1
}
 
restart_crond(){

    echo "Stop crond jobs"
    sudo killall crond

    echo "Start crond jobs"
    nohup sudo crond -p   </dev/null >> ${LOGPATH}/crond.log 2>&1  &
    echo "Config the crond jobs for ${TEST_ENV}"
    if [[ "x${TEST_ENV}" == "xpre" ||  "x${TEST_ENV}" == "xonline"  ]];then
        sed -i 's/TEST_ENV/'${TEST_ENV}'/g' ${WS}/monitor/*
    else
        echo "Invalid TEST_ENV: ${TEST_ENV}"
        exit 1
    fi
    echo "Copy the crond jobs config file(s) in the ${WS}/monitor/ to /etc/cron.d/"
    sudo cp -f ${WS}/monitor/* /etc/cron.d/
} 
 
checkhealth(){
    if [[ -n "$PROC_PORT" ]] ; then
        curl -is "http://localhost:$PROC_PORT/$PROC_URI" | grep "$RESPONSE" >/dev/null 2>&1
        if [[ "$?" = 0 ]] ; then
            echo "running"
            return 0
        fi
            echo " not running"
        return 1
   else
       ps -eo comm,pid |grep -P  "^$PROC_NAME"
       if [[ "$?" = 0 ]] ; then
           echo "running"
           return 0
       fi
       echo "not running"
       return 1
   fi
}
 
start(){
    checkhealth
    if [[ $? = 0 ]]; then
        echo "[WARN] $PROC_NAME is aleady running!"
        return 0
    fi
    
    # crond do not run by default, need to restart crond for it.
    restart_crond >> ${CRONDJLOGFILE} 2>&1  &

    cd ${WS}/CronUI
    nohup ${START_COMMAND}  </dev/null >> ${WEBLOGFILE} 2>&1 &
    nohup ${START_COMMAND_TCP_SERVER} </dev/null >> ${TCPLOGFILE} 2>&1 &
 
 
    for i in $(seq ${WAIT_TIME}) ; do
        sleep 1
        checkhealth
        if [[ $? = 0 ]]; then
            echo "Start $PROC_NAME success"
            return 0
        fi
    done
    echo "[ERROR] Start $PROC_NAME failed"
    return 1
}
 
stop(){
    PROC_ID=$(ps -eo comm,pid  | grep "^$PROC_NAME" |awk '{print $2}')
 
    if [[ -z "$PROC_ID" ]] ; then
        echo "[WARN] $PROC_NAME is aleady exit, skip stop"
        return 0        
    fi
 
    checkhealth
    if [[ "$?" != "0" ]] ; then
        echo "[WARN] $PROC_NAME is aleady exit, skip stop"
        return 0
    fi
    sudo killall ${TCP_SERVER_NAME}
    sudo pkill ${PROC_NAME}
    for i in $(seq $WAIT_TIME) ; do
        sleep 1
        checkhealth
        if [[ "$?" != "0" ]] ; then
            echo "Stop $PROC_NAME success"
            return 0
        fi
    done

    sudo killall ${TCP_SERVER_NAME}
    sudo pkill ${PROC_NAME}
    sleep 1
    checkhealth
    if [[ "$?" != "0" ]] ; then
        echo "Stop $PROC_NAME success"
        return 0
    fi
 
    echo "[ERROR] Stop $PROC_NAME failed"
    return 1
}
 
case "${1}" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    status|health|checkhealth)
        checkhealth
        ;;
    restart)
        stop && start
        ;;
    *)
        help
        ;;
esac
